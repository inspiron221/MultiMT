#!/usr/bin/env python
# -*- coding: utf-8 -*-
# create configuration file moses.ini from multiple phrase tables
# Use: Multiple translation tables and back-off model
# Assume that we have uk-en-ru --> cs with uk is the main language
# Then uk-cs is the main ttable, en and ru is the back-off model
# 


from __future__ import division, unicode_literals
import sys
import os
import gzip
import argparse
import copy
import re
from math import log, exp
from collections import defaultdict
from operator import mul
from tempfile import NamedTemporaryFile

try:
    from itertools import izip
except:
    izip = zip

def parse_command_line():
    parser = argparse.ArgumentParser(description='Find the pair of data given in a directory, all the options will be implemented later')

    group1 = parser.add_argument_group('Main options')

    group1.add_argument('-TMS', metavar='DIRECTORY', dest='TMS',
                    help='list of all ttables that you want to include, the first table is the main')
    group1.add_argument('-o', metavar='DIRECTORY', dest='output_file',
                    help='the output file moses.ini')

    return parser.parse_args()


class Config_Moses():
    """This class handles the process of looking for a specific
       it also check the correctness of the bilingual corpus which they have the same line number or not
    """

    def __init__(self,tms=None,
                      output_file=None):

        ''' Initialize the value, list all the folder in the directory
        '''
        tms = tms.split(':')
        if (len(tms) < 1) :
            print "DIE BECAUSE OF WRONG FORMAT"
        self.ttable_main = tms[0]
        self.ttable_add = tms[1:]
        self.output_file = output_file
        self.input_factor = []
        self.mapping = []
        self.distortion_limit = []
        self.feature = []
        self.weight = []
        self.decoding_graph_backoff = []


    def _ensure_format(self):
        '''
        make sure that all ttable has the same target language
        '''
        return None

# GLOBAL DEF
def handle_file(filename,action,fileobj=None,mode='r'):
    """support reading/writing either from/to file, stdout or gzipped file"""

    if action == 'open':

        if mode == 'r':
            mode = 'rb'
        elif mode == 'w':
            mode = 'wb'

        if mode == 'rb' and not filename == '-' and not os.path.exists(filename):
            if os.path.exists(filename+'.gz'):
                filename = filename+'.gz'
            else:
                sys.stderr.write('Error: unable to open file. ' + filename + ' - aborting.\n')

                if 'counts' in filename and os.path.exists(os.path.dirname(filename)):
                    sys.stderr.write('For a weighted counts combination, we need statistics that Moses doesn\'t write to disk by default.\n')
                    sys.stderr.write('Repeat step 4 of Moses training for all models with the option -write-lexical-counts.\n')

                exit(1)

        if filename.endswith('.gz'):
            fileobj = gzip.open(filename,mode)

        elif filename == '-' and mode == 'wb':
            fileobj = sys.stdout

        else:
                fileobj = open(filename,mode)

        return fileobj

    elif action == 'close' and filename != '-':
        fileobj.close()



def dot_product(a,b):
    """calculate dot product from two lists"""

    # optimized for PyPy (much faster than enumerate/map)
    s = 0
    i = 0
    for x in a:
        s += x * b[i]
        i += 1

    return s



if __name__ == "__main__":

    if len(sys.argv) < 2:
        sys.stderr.write("no command specified. use option -h for usage instructions\n")

    elif sys.argv[1] == "test":
        test()

    else:
        args = parse_command_line()
        #initialize
        print "OK, Let's play!"
        cm = Config_Moses(tms=args.TMS,
                            output_file=args.output_file)
