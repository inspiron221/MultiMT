#!/usr/bin/env python
# -*- coding: utf-8 -*-
# create configuration file moses.ini from multiple phrase tables
# Use: Multiple translation tables and back-off model
# Assume that we have uk-en-ru --> cs with uk is the main language
# Then uk-cs is the main ttable, en and ru is the back-off model
# 

from __future__ import division, unicode_literals
import sys
import os
import gzip
import argparse
import copy
import re
from math import log, exp
from collections import defaultdict
from operator import mul
from tempfile import NamedTemporaryFile

try:
    from itertools import izip
except:
    izip = zip

def parse_command_line():
    parser = argparse.ArgumentParser(description='Find the pair of data given in a directory, all the options will be implemented later')

    group1 = parser.add_argument_group('Main options')

    group1.add_argument('-TMS', metavar='DIRECTORY', dest='TMS',
                    help='list of all ttables that you want to include, the first table is the main')
    group1.add_argument('-o', metavar='DIRECTORY', dest='output_file',
                    help='the output file moses.ini')

    return parser.parse_args()


class Ttable():
    '''
    This class keeps the factors of a ttable
    '''
    def __init__(self,name='TranslationModel',
                      num_features=4,
                      path=None,
                      input_factor=0,
                      output_factor=0,
                      table_limit=20):
        self.name = name
        self.num_features=num_features
        self.path=path
        self.input_factor=input_factor
        self.output_factor=output_factor
        self.table_limit=table_limit

    def _write_config(self):
        '''
        Write the configuration of phrase table
        '''
        outline=[]
        outline.append('PhraseDictionaryMemory')
        outline.append('name='+self.name)
        outline.append('num-features='+str(self.num_features))
        outline.append('path='+self.path)
        outline.append('input-factor='+str(self.input_factor))
        outline.append('output-factor='+str(self.output_factor))
        outline.append('table-limit='+str(self.table_limit))

        return b' '.join(outline)


class Config_Moses():
    """This class handles the process of looking for a specific
       it also check the correctness of the bilingual corpus which they have the same line number or not
    """

    def __init__(self,tms=None,
                      output_file=None):

        ''' Initialize the value, list all the folder in the directory
        '''
        tms = tms.split(':')
        if (len(tms) < 1) :
            print "DIE BECAUSE OF WRONG FORMAT"
        
        for tmId in range(len(tms)):
            tmcopy = tms[tmId]
            if ("phrase-table" not in tms[tmId]):
                onlyfiles = [f for f in os.listdir(tms[tmId]+b"/model/")]
                for f in onlyfiles:
                    if (b"phrase-table" in f):
                        tms[tmId] += b"/model/"+f
            else:
                tms[tmId] = os.path.abspath(tms[tmId])

            # convert path to ttable
            tms[tmId] = Ttable(name='TranslationModel'+str(tmId), path=tms[tmId])

        self.ttable_main = tms[0]
        self.ttable_add = tms[1:]
        self.num_add = len(self.ttable_add)
        print self.ttable_main, self.ttable_add
        self.output_file = output_file
        self.input_factor = []
        self.mapping = []
        self.distortion_limit = []
        self.feature = []
        self.weight = []
        self.decoding_graph_backoff = []

        
        # perform everything
        self._set_config()
        self._write_config()

    def _ensure_format(self):
        '''
        make sure that all ttable has the same target language
        '''
        return None
    def _write_config(self):
        ''' write the moses.ini file
        '''
        output_object = handle_file(self.output_file, 'open', mode='w')
        sys.stderr.write("Start writing file " + self.output_file + "\n")
        output_object.write('# Generated by merge_moses_models.pl from files:\n')
        output_object.write('#\n')
        output_object.write('# ' + self.ttable_main.path + '\n')
        for table in self.ttable_add:
            output_object.write('# ' + table.path + '\n')
        output_object.write('\n')
        
        write_list(self.input_factor, output_object)
        write_list(self.mapping, output_object)
        write_list(self.decoding_graph_backoff, output_object)
        write_list(self.distortion_limit, output_object)
        write_list(self.feature, output_object)
        write_list(self.weight, output_object)
        handle_file(self.output_file,'close',output_object,mode='w')

        sys.stderr.write("Done\n")
    def _set_config(self):
        '''
        Set the file configuration of moses.ini
        '''
        # [input-factors]
        self.input_factor.append('[input-factors]')
        self.input_factor.append(0) # the main phrase
        self.input_factor.append(1) # indicate additional phrase

        # [mapping]
        self.mapping.append('[mapping]')
        self.mapping.append('0 T 0')
        for i in range(self.num_add):
            self.mapping.append('1 T '+str(i+1))

        # [distortion-limit]
        self.distortion_limit.append('[distortion-limit]')
        self.distortion_limit.append(6)

        # [feature]
        self.feature.append('[feature]')
        self.feature.append('Distortion')
        self.feature.append('KENLM lazyken=0 name=LM0 factor=0 path=/a/merkur3/thoang/domain_adapt/ufal-smt-playground/czeng_europarl_playground/s.model.17bd81b4.20141130-0040/lm.1.corpus.lm.gz order=4')
        self.feature.append(self.ttable_main._write_config())
        for ttable in self.ttable_add:
            self.feature.append(ttable._write_config())
        self.feature.append('PhrasePenalty')
        self.feature.append('UnknownWordPenalty')
        self.feature.append('WordPenalty')

        # [weight]
        self.weight.append('[weight]')
        self.weight.append('Distortion0= 0.3')
        self.weight.append('LM0= 0.5')
        self.weight.append('PhrasePenalty0= 0.2')
        self.weight.append('TranslationModel0= 0.2 0.2 0.2 0.2')
        for tmId in range(len(self.ttable_add)):
            self.weight.append('TranslationModel' + str(tmId+1) + '= 0.2 0.2 0.2 0.2')
        self.weight.append('UnknownWordPenalty0= 1')
        self.weight.append('WordPenalty= -1')
        
        # [decoding-graph-backoff]
        self.decoding_graph_backoff.append('[decoding-graph-backoff]')
        self.decoding_graph_backoff.append(0)
        self.decoding_graph_backoff.append(1)

        return None 
    

# GLOBAL DEF

def write_list(wlist,out_object):
    """ write the list to a file object """
    for line in wlist:
        out_object.write(str(line)+b"\n")
    out_object.write(b"\n")
    return None

def handle_file(filename,action,fileobj=None,mode='r'):
    """support reading/writing either from/to file, stdout or gzipped file"""

    if action == 'open':

        if mode == 'r':
            mode = 'rb'
        elif mode == 'w':
            mode = 'wb'

        if mode == 'rb' and not filename == '-' and not os.path.exists(filename):
            if os.path.exists(filename+'.gz'):
                filename = filename+'.gz'
            else:
                sys.stderr.write('Error: unable to open file. ' + filename + ' - aborting.\n')

                if 'counts' in filename and os.path.exists(os.path.dirname(filename)):
                    sys.stderr.write('For a weighted counts combination, we need statistics that Moses doesn\'t write to disk by default.\n')
                    sys.stderr.write('Repeat step 4 of Moses training for all models with the option -write-lexical-counts.\n')

                exit(1)

        if filename.endswith('.gz'):
            fileobj = gzip.open(filename,mode)

        elif filename == '-' and mode == 'wb':
            fileobj = sys.stdout

        else:
                fileobj = open(filename,mode)

        return fileobj

    elif action == 'close' and filename != '-':
        fileobj.close()



def dot_product(a,b):
    """calculate dot product from two lists"""

    # optimized for PyPy (much faster than enumerate/map)
    s = 0
    i = 0
    for x in a:
        s += x * b[i]
        i += 1

    return s



if __name__ == "__main__":

    if len(sys.argv) < 2:
        sys.stderr.write("no command specified. use option -h for usage instructions\n")

    elif sys.argv[1] == "test":
        test()

    else:
        args = parse_command_line()
        #initialize
        print "OK, Let's play!"
        cm = Config_Moses(tms=args.TMS,
                            output_file=args.output_file)
